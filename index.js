const { Client, GatewayIntentBits, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');

class VoiceChatLeaderboard {
    constructor() {
        this.client = new Client({
            intents: [
                GatewayIntentBits.Guilds,
                GatewayIntentBits.GuildVoiceStates,
                GatewayIntentBits.GuildMessages,
                GatewayIntentBits.MessageContent
            ]
        });

        // ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏ß‡∏•‡∏≤ voice chat ‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞ user
        this.voiceData = new Map(); // userId -> { totalTime, joinTime, isInVoice }
        this.leaderboardChannel = null;
        
        this.setupEvents();
    }

    setupEvents() {
        this.client.once('ready', () => {
            console.log(`‚úÖ Bot ‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏•‡πâ‡∏ß‡πÉ‡∏ô‡∏ä‡∏∑‡πà‡∏≠ ${this.client.user.tag}`);
            this.updateLeaderboardPeriodically();
        });

        // ‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏° voice state changes
        this.client.on('voiceStateUpdate', (oldState, newState) => {
            this.handleVoiceStateUpdate(oldState, newState);
        });

        // ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ slash commands ‡πÅ‡∏•‡∏∞ button interactions
        this.client.on('interactionCreate', async (interaction) => {
            if (interaction.isCommand()) {
                await this.handleSlashCommand(interaction);
            } else if (interaction.isButton()) {
                await this.handleButtonInteraction(interaction);
            }
        });

        // ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÅ‡∏ö‡∏ö text
        this.client.on('messageCreate', (message) => {
            if (message.author.bot) return;
            this.handleTextCommand(message);
        });
    }

    handleVoiceStateUpdate(oldState, newState) {
        const userId = newState.id;
        const now = Date.now();

        // ‡∏ñ‡πâ‡∏≤‡πÄ‡∏Ç‡πâ‡∏≤ voice channel
        if (!oldState.channel && newState.channel) {
            if (!this.voiceData.has(userId)) {
                this.voiceData.set(userId, { totalTime: 0, joinTime: now, isInVoice: true });
            } else {
                const userData = this.voiceData.get(userId);
                userData.joinTime = now;
                userData.isInVoice = true;
            }
            console.log(`üë§ ${newState.member.displayName} ‡πÄ‡∏Ç‡πâ‡∏≤ voice channel`);
        }
        
        // ‡∏ñ‡πâ‡∏≤‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å voice channel
        else if (oldState.channel && !newState.channel) {
            if (this.voiceData.has(userId)) {
                const userData = this.voiceData.get(userId);
                if (userData.isInVoice && userData.joinTime) {
                    const sessionTime = now - userData.joinTime;
                    userData.totalTime += sessionTime;
                    userData.isInVoice = false;
                    userData.joinTime = null;
                    console.log(`üëã ${oldState.member.displayName} ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å voice channel (‡πÄ‡∏ß‡∏•‡∏≤: ${this.formatTime(sessionTime)})`);
                }
            }
        }
    }

    async handleSlashCommand(interaction) {
        switch (interaction.commandName) {
            case 'leaderboard':
                await this.showLeaderboard(interaction, 0);
                break;
            case 'setleaderboard':
                await this.setLeaderboardChannel(interaction);
                break;
            case 'mytime':
                await this.showUserTime(interaction);
                break;
            case 'resetleaderboard':
                await this.resetLeaderboard(interaction);
                break;
        }
    }

    async handleButtonInteraction(interaction) {
        const [action, page] = interaction.customId.split('_');
        const pageNum = parseInt(page);

        if (action === 'prev' || action === 'next') {
            await this.showLeaderboard(interaction, pageNum, true);
        }
    }

    async handleTextCommand(message) {
        const prefix = '!';
        if (!message.content.startsWith(prefix)) return;

        const args = message.content.slice(prefix.length).trim().split(/ +/);
        const command = args.shift().toLowerCase();

        switch (command) {
            case 'leaderboard':
            case 'lb':
                await this.showLeaderboard(message, 0);
                break;
            case 'setleaderboard':
                if (!message.member.permissions.has('MANAGE_CHANNELS')) {
                    return message.reply('‚ùå ‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ leaderboard channel');
                }
                this.leaderboardChannel = message.channel;
                await message.reply('‚úÖ ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ leaderboard channel ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß');
                break;
            case 'mytime':
                await this.showUserTime(message);
                break;
        }
    }

    async showLeaderboard(interaction, page = 0, isUpdate = false) {
        const itemsPerPage = 10;
        const sortedUsers = this.getSortedLeaderboard();
        const totalPages = Math.ceil(sortedUsers.length / itemsPerPage);
        
        if (page >= totalPages) page = totalPages - 1;
        if (page < 0) page = 0;

        const start = page * itemsPerPage;
        const end = start + itemsPerPage;
        const pageUsers = sortedUsers.slice(start, end);

        const embed = new EmbedBuilder()
            .setTitle('üèÜ Voice Chat Leaderboard')
            .setColor(0x00AE86)
            .setTimestamp()
            .setFooter({ text: `‡∏´‡∏ô‡πâ‡∏≤ ${page + 1}/${totalPages || 1} ‚Ä¢ ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î` });

        if (pageUsers.length === 0) {
            embed.setDescription('‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• voice chat');
        } else {
            let description = '';
            for (let i = 0; i < pageUsers.length; i++) {
                const rank = start + i + 1;
                const { user, totalTime, isInVoice } = pageUsers[i];
                const member = await interaction.guild?.members.fetch(user).catch(() => null);
                const displayName = member?.displayName || 'Unknown User';
                
                const medal = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : 'üèÖ';
                const status = isInVoice ? 'üîä' : 'üí§';
                
                description += `${medal} **#${rank}** ${status} **${displayName}**\n`;
                description += `‚è±Ô∏è ${this.formatTime(totalTime)}\n\n`;
            }
            embed.setDescription(description);
        }

        const row = new ActionRowBuilder();
        
        if (totalPages > 1) {
            row.addComponents(
                new ButtonBuilder()
                    .setCustomId(`prev_${page - 1}`)
                    .setLabel('‚óÄÔ∏è ‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤')
                    .setStyle(ButtonStyle.Primary)
                    .setDisabled(page === 0),
                new ButtonBuilder()
                    .setCustomId(`next_${page + 1}`)
                    .setLabel('‡∏ñ‡∏±‡∏î‡πÑ‡∏õ ‚ñ∂Ô∏è')
                    .setStyle(ButtonStyle.Primary)
                    .setDisabled(page === totalPages - 1)
            );
        }

        const messageOptions = { 
            embeds: [embed], 
            components: row.components.length > 0 ? [row] : [] 
        };

        if (isUpdate) {
            await interaction.update(messageOptions);
        } else if (interaction.isCommand?.()) {
            await interaction.reply(messageOptions);
        } else {
            await interaction.reply(messageOptions);
        }
    }

    async showUserTime(interaction) {
        const userId = interaction.user?.id || interaction.author?.id;
        const userData = this.voiceData.get(userId);
        
        let totalTime = 0;
        let status = '‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô voice channel';
        
        if (userData) {
            totalTime = userData.totalTime;
            if (userData.isInVoice && userData.joinTime) {
                totalTime += Date.now() - userData.joinTime;
                status = 'üîä ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô voice channel';
            }
        }

        const embed = new EmbedBuilder()
            .setTitle('‚è±Ô∏è ‡πÄ‡∏ß‡∏•‡∏≤ Voice Chat ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì')
            .setDescription(`**‡πÄ‡∏ß‡∏•‡∏≤‡∏£‡∏ß‡∏°:** ${this.formatTime(totalTime)}\n**‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞:** ${status}`)
            .setColor(0x3498DB)
            .setTimestamp();

        if (interaction.isCommand?.()) {
            await interaction.reply({ embeds: [embed], ephemeral: true });
        } else {
            await interaction.reply({ embeds: [embed] });
        }
    }

    async setLeaderboardChannel(interaction) {
        if (!interaction.member.permissions.has('MANAGE_CHANNELS')) {
            return await interaction.reply({ content: '‚ùå ‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ leaderboard channel', ephemeral: true });
        }

        this.leaderboardChannel = interaction.channel;
        await interaction.reply('‚úÖ ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ leaderboard channel ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß');
    }

    async resetLeaderboard(interaction) {
        if (!interaction.member.permissions.has('ADMINISTRATOR')) {
            return await interaction.reply({ content: '‚ùå ‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï leaderboard', ephemeral: true });
        }

        this.voiceData.clear();
        await interaction.reply('‚úÖ ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï leaderboard ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß');
    }

    getSortedLeaderboard() {
        const users = [];
        const now = Date.now();

        for (const [userId, userData] of this.voiceData.entries()) {
            let totalTime = userData.totalTime;
            
            // ‡∏£‡∏ß‡∏°‡πÄ‡∏ß‡∏•‡∏≤‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏ñ‡πâ‡∏≤‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô voice channel
            if (userData.isInVoice && userData.joinTime) {
                totalTime += now - userData.joinTime;
            }

            if (totalTime > 0) {
                users.push({
                    user: userId,
                    totalTime: totalTime,
                    isInVoice: userData.isInVoice
                });
            }
        }

        return users.sort((a, b) => b.totalTime - a.totalTime);
    }

    formatTime(milliseconds) {
        const seconds = Math.floor(milliseconds / 1000);
        const minutes = Math.floor(seconds / 60);
        const hours = Math.floor(minutes / 60);
        const days = Math.floor(hours / 24);

        if (days > 0) {
            return `${days}d ${hours % 24}h ${minutes % 60}m`;
        } else if (hours > 0) {
            return `${hours}h ${minutes % 60}m`;
        } else if (minutes > 0) {
            return `${minutes}m ${seconds % 60}s`;
        } else {
            return `${seconds}s`;
        }
    }

    updateLeaderboardPeriodically() {
        setInterval(async () => {
            if (this.leaderboardChannel) {
                try {
                    const messages = await this.leaderboardChannel.messages.fetch({ limit: 1 });
                    const lastMessage = messages.first();
                    
                    if (lastMessage && lastMessage.author.id === this.client.user.id && lastMessage.embeds.length > 0) {
                        // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó leaderboard ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß
                        await this.showLeaderboard({ 
                            guild: this.leaderboardChannel.guild,
                            update: async (options) => await lastMessage.edit(options)
                        }, 0, true);
                    }
                } catch (error) {
                    console.error('Error updating leaderboard:', error);
                }
            }
        }, 60000); // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏ó‡∏∏‡∏Å 1 ‡∏ô‡∏≤‡∏ó‡∏µ
    }

    async start(token) {
        try {
            await this.client.login(token);
        } catch (error) {
            console.error('‚ùå Error starting bot:', error);
        }
    }
}

// ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Replit
const bot = new VoiceChatLeaderboard();

// ‡πÄ‡∏£‡∏¥‡πà‡∏° bot (‡πÉ‡∏ä‡πâ environment variable ‡∏à‡∏≤‡∏Å Replit)
const token = process.env.DISCORD_TOKEN;
if (token) {
    bot.start(token);
    console.log('üöÄ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏£‡∏¥‡πà‡∏° bot ‡∏ö‡∏ô Replit...');
} else {
    console.error('‚ùå ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÉ‡∏™‡πà DISCORD_TOKEN ‡πÉ‡∏ô Environment Variables ‡∏Ç‡∏≠‡∏á Replit');
}

// Keep alive server ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Replit
const express = require('express');
const app = express();
const port = process.env.PORT || 3000;

app.get('/', (req, res) => {
    res.send(`
        <h1>ü§ñ Discord Voice Leaderboard Bot</h1>
        <p>Status: ${bot.client.isReady() ? '‚úÖ Online' : '‚ùå Offline'}</p>
        <p>Servers: ${bot.client.guilds.cache.size}</p>
        <p>Users being tracked: ${bot.voiceData.size}</p>
    `);
});

app.get('/health', (req, res) => {
    res.json({ 
        status: 'ok', 
        uptime: process.uptime(),
        botReady: bot.client.isReady()
    });
});

app.listen(port, () => {
    console.log(`üåê Web server running on port ${port}`);
});

// Export ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå‡∏≠‡∏∑‡πà‡∏ô
module.exports = VoiceChatLeaderboard;

/* 
üöÄ ‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏•‡∏∞‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏ö‡∏ô Replit:

1. ‡∏™‡∏£‡πâ‡∏≤‡∏á Repl ‡πÉ‡∏´‡∏°‡πà:
- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Node.js template
- Copy ‡πÇ‡∏Ñ‡πâ‡∏î‡∏ô‡∏µ‡πâ‡πÑ‡∏õ‡πÉ‡∏™‡πà‡πÉ‡∏ô index.js

2. ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå package.json:
{
  "name": "discord-voice-leaderboard",
  "version": "1.0.0",
  "description": "Discord bot for voice chat leaderboard",
  "main": "index.js",
  "scripts": {
    "start": "node index.js"
  },
  "dependencies": {
    "discord.js": "^14.14.1",
    "express": "^4.18.2"
  }
}

3. ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ Environment Variables ‡πÉ‡∏ô Replit:
- ‡πÑ‡∏õ‡∏ó‡∏µ‡πà Secrets tab (üîí)
- ‡πÄ‡∏û‡∏¥‡πà‡∏° key: DISCORD_TOKEN
- ‡πÄ‡∏û‡∏¥‡πà‡∏° value: token ‡∏Ç‡∏≠‡∏á bot

4. ‡∏™‡∏£‡πâ‡∏≤‡∏á Discord Bot:
- ‡πÑ‡∏õ‡∏ó‡∏µ‡πà https://discord.com/developers/applications
- ‡∏™‡∏£‡πâ‡∏≤‡∏á New Application
- ‡πÑ‡∏õ‡∏ó‡∏µ‡πà Bot tab ‡πÅ‡∏•‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á bot
- Copy token ‡∏°‡∏≤‡πÉ‡∏™‡πà‡πÉ‡∏ô Secrets

5. ‡πÄ‡∏ä‡∏¥‡∏ç bot ‡πÄ‡∏Ç‡πâ‡∏≤ server:
- ‡πÑ‡∏õ‡∏ó‡∏µ‡πà OAuth2 > URL Generator
- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Scopes: bot, applications.commands
- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Bot Permissions: 
  ‚úÖ Send Messages
  ‚úÖ Use Slash Commands  
  ‚úÖ Read Message History
  ‚úÖ Connect
  ‚úÖ View Channels
  ‚úÖ Embed Links
- Copy URL ‡πÅ‡∏•‡∏∞‡πÄ‡∏ä‡∏¥‡∏ç bot

6. ‡∏£‡∏±‡∏ô bot:
- ‡∏Å‡∏î Run button ‡πÉ‡∏ô Replit
- Bot ‡∏à‡∏∞‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÅ‡∏•‡∏∞‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ó‡∏µ‡πà web interface

üì± ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô:
- ‡πÄ‡∏Ç‡πâ‡∏≤ https://your-repl-name.your-username.repl.co ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ bot
- Bot ‡∏à‡∏∞‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ï‡∏•‡∏≠‡∏î‡πÄ‡∏ß‡∏•‡∏≤‡∏ö‡∏ô Replit (‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô Replit Core/Teams)

‚ö†Ô∏è ‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç:
- Replit ‡∏ü‡∏£‡∏µ‡∏à‡∏∞ sleep ‡∏´‡∏•‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô ‡∏Ñ‡∏ß‡∏£‡πÉ‡∏ä‡πâ UptimeRobot ‡∏´‡∏£‡∏∑‡∏≠ service ping
- ‡∏´‡∏£‡∏∑‡∏≠ upgrade ‡πÄ‡∏õ‡πá‡∏ô Replit Core ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏£‡∏±‡∏ô‡∏ï‡∏•‡∏≠‡∏î‡πÄ‡∏ß‡∏•‡∏≤

üìù ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ:

Text Commands:
- !leaderboard ‡∏´‡∏£‡∏∑‡∏≠ !lb - ‡πÅ‡∏™‡∏î‡∏á leaderboard
- !setleaderboard - ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ channel ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö auto-update
- !mytime - ‡∏î‡∏π‡πÄ‡∏ß‡∏•‡∏≤‡∏Ç‡∏≠‡∏á‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á

Slash Commands (‡∏ï‡πâ‡∏≠‡∏á register ‡∏Å‡πà‡∏≠‡∏ô):
- /leaderboard - ‡πÅ‡∏™‡∏î‡∏á leaderboard
- /setleaderboard - ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ channel
- /mytime - ‡∏î‡∏π‡πÄ‡∏ß‡∏•‡∏≤‡∏Ç‡∏≠‡∏á‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á
- /resetleaderboard - ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• (Admin ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô)

‚ú® Features:
- ‚úÖ ‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡πÄ‡∏ß‡∏•‡∏≤ voice chat ‡πÅ‡∏ö‡∏ö real-time
- ‚úÖ Leaderboard ‡πÅ‡∏ö‡∏ö‡πÅ‡∏ö‡πà‡∏á‡∏´‡∏ô‡πâ‡∏≤ (pagination)
- ‚úÖ ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡∏ó‡∏∏‡∏Å‡∏ô‡∏≤‡∏ó‡∏µ
- ‚úÖ ‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ß‡πà‡∏≤‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô voice ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
- ‚úÖ ‡∏™‡∏ô‡∏±‡∏ö‡∏™‡∏ô‡∏∏‡∏ô‡∏ó‡∏±‡πâ‡∏á text commands ‡πÅ‡∏•‡∏∞ slash commands
- ‚úÖ Button navigation ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏î‡∏π leaderboard
- ‚úÖ ‡∏£‡∏∞‡∏ö‡∏ö permission ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ï‡πà‡∏≤‡∏á‡πÜ
- ‚úÖ Web dashboard ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏π‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ bot
- ‚úÖ Keep alive system ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Replit
*/